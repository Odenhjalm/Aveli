import uuid

import pytest

from app import db, models
from app.config import settings
from app.utils import media_signer

pytestmark = pytest.mark.anyio("asyncio")


def auth_header(token: str) -> dict[str, str]:
    return {"Authorization": f"Bearer {token}"}


async def register_teacher(async_client) -> tuple[dict[str, str], str]:
    email = f"telemetry_teacher_{uuid.uuid4().hex[:8]}@example.com"
    password = "Secret123!"
    register_resp = await async_client.post(
        "/auth/register",
        json={"email": email, "password": password, "display_name": "Teacher"},
    )
    assert register_resp.status_code == 201, register_resp.text
    tokens = register_resp.json()
    headers = auth_header(tokens["access_token"])
    me_resp = await async_client.get("/auth/me", headers=headers)
    assert me_resp.status_code == 200, me_resp.text
    user_id = str(me_resp.json()["user_id"])
    async with db.pool.connection() as conn:  # type: ignore[attr-defined]
        async with conn.cursor() as cur:  # type: ignore[attr-defined]
            await cur.execute(
                "UPDATE app.profiles SET role_v2 = 'teacher' WHERE user_id = %s",
                (user_id,),
            )
            await conn.commit()
    return headers, user_id


async def create_course_and_lesson(async_client, headers) -> tuple[str, str]:
    slug = f"telemetry-course-{uuid.uuid4().hex[:6]}"
    course_resp = await async_client.post(
        "/studio/courses",
        headers=headers,
        json={
            "title": "Telemetry Course",
            "slug": slug,
            "description": "Course for telemetry tests",
            "is_published": True,
        },
    )
    assert course_resp.status_code == 200, course_resp.text
    course_id = str(course_resp.json()["id"])

    lesson_resp = await async_client.post(
        "/studio/lessons",
        headers=headers,
        json={
            "course_id": course_id,
            "title": "Lesson",
            "content_markdown": "# Lesson",
            "position": 1,
            "is_intro": False,
        },
    )
    assert lesson_resp.status_code == 200, lesson_resp.text
    lesson_id = str(lesson_resp.json()["id"])
    return course_id, lesson_id


async def ensure_telemetry_tables():
    async with db.pool.connection() as conn:  # type: ignore[attr-defined]
        async with conn.cursor() as cur:  # type: ignore[attr-defined]
            await cur.execute(
                """
                CREATE TABLE IF NOT EXISTS app.media_resolution_failures (
                  id bigint generated by default as identity primary key,
                  created_at timestamptz not null default now(),
                  lesson_media_id uuid references app.lesson_media(id) on delete set null,
                  mode text not null,
                  reason text not null,
                  details jsonb not null default '{}'::jsonb
                )
                """
            )
            await conn.commit()


async def test_media_stream_records_telemetry_on_missing_file(async_client, monkeypatch):
    await ensure_telemetry_tables()

    # Force deterministic "storage disabled" path in /media/stream.
    monkeypatch.setattr(settings, "supabase_url", None, raising=False)
    monkeypatch.setattr(settings, "supabase_service_role_key", None, raising=False)

    # Enable signing for /media/sign and /media/stream.
    monkeypatch.setattr(media_signer.settings, "media_signing_secret", "dev-secret", raising=False)
    monkeypatch.setattr(media_signer.settings, "media_signing_ttl_seconds", 60, raising=False)

    headers, _ = await register_teacher(async_client)
    _, lesson_id = await create_course_and_lesson(async_client, headers)

    unique_path = f"course-media/missing/{uuid.uuid4().hex}/demo.png"
    lesson_media = await models.add_lesson_media_entry_with_position_retry(
        lesson_id=lesson_id,
        kind="image",
        storage_path=unique_path,
        storage_bucket="course-media",
        media_id=None,
        media_asset_id=None,
        duration_seconds=None,
        max_retries=5,
    )
    assert lesson_media
    lesson_media_id = str(lesson_media["id"])

    sign_resp = await async_client.post(
        "/media/sign",
        headers=headers,
        json={"media_id": lesson_media_id, "mode": "student_render"},
    )
    assert sign_resp.status_code == 200, sign_resp.text
    signed_url = sign_resp.json()["signed_url"]

    stream_resp = await async_client.get(signed_url)
    assert stream_resp.status_code == 404, stream_resp.text

    async with db.pool.connection() as conn:  # type: ignore[attr-defined]
        async with conn.cursor() as cur:  # type: ignore[attr-defined]
            await cur.execute(
                """
                SELECT mode, reason
                FROM app.media_resolution_failures
                WHERE lesson_media_id = %s
                ORDER BY created_at DESC
                LIMIT 1
                """,
                (lesson_media_id,),
            )
            row = await cur.fetchone()
    assert row is not None
    mode, reason = row
    assert mode == "student_render"
    assert reason == "key_format_drift"
